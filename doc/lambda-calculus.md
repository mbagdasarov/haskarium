# Элементы лямбда-исчисления

## Аппликация

Синонимы:
- применение (функции к аргументу)
- вызов функции (с передачей аргумента)

```haskell

-- каноническая форма аппликации
f x

----

-- вложенная аппликация
f (g x)

----

-- результат первого применения — функция для второго применения
((f x) y) z

----

-- договоримся, что аппликация ассоциативна слева
f x y z
-- то есть если расставить скобки слева, получится предыдущее выражение

```

## Абстракция — понятие

```haskell

-- пусть у нас есть две функции
f x = x * 2 + 1
g x = x * 2 + 1

-- они одинаковые или разные?

----

-- по сути, по действию, оказываемому на аргумент, это одна и та же функция

-- давайте абстрагируемся от имени и запишем только действие этой функции

\x -> x * 2 + 1

```

## Абстракция

Синонимы:
- лямбда-абстракция
- лямбда-выражение
- анонимная функция

«Лямбда-функция» — некорректно,
потому что результат лямбда-абстракции — обычная функция.

```haskell

-- простейший пример (лямбда-)абстракции
-- (в Хаскелле мы пишем стрелку вместо точки
-- и бэкслэш вместо лямбды,
-- но всё остальное такое же, как у Чёрча)
\x -> y

----

-- вложенная абстракция
\x -> (\y -> z)

----

-- после применения этой функции получится новая функция
\x -> (\y -> (\z -> a))

----

-- договоримся, что абстракция ассоциативна справа
\x -> \y -> \z -> a
-- то есть если расставить скобки справа, получится предыдущее выражение

----

-- договоримся, что несколько абстракций подряд можно записывать компактно
\x y z -> a
-- то есть функция от нескольких аргументов —
-- это цепочка функций от каждого из них

```

## Преобразования функциональных формул

### Замена переменной (альфа-эквивалентность)

```haskell

\x -> ... x ...
\y -> ... y ...

```

При условии, что заменяются вхождения только этой переменной
(но не другой с таким же именем) и новая переменная ещё не встречается в теле.

### Подстановка (бета-редукция)

```haskell

(\x -> expr[x]) a = expr[x := a] -- псевдокод

[x := a] -- замена всех вхождений переменной `x` на выражение `a`

-- пример
(\x -> x + x) a = a + a

```

### Применение к одному аргументу (эта-преобразование)

```haskell

-- идея
f == g  <=>  f x == g x

(\x -> f x) == f

```

### Определение функции с аргументами (специфика Хаскелла)

```haskell

-- от одного аргумента
f  =  \x  ->  expr
f      x   =  expr

-- от нескольких аргументов
f  =  \x  ->  \y  ->  \z  ->  expr
f  =  \x       y       z  ->  expr
f      x       y       z   =  expr

f  =  \x  ->  \y  ->  \z  ->  expr
f      x   =  \y  ->  \z  ->  expr
f      x       y   =  \z  ->  expr
f      x       y       z   =  expr

```

## Простейшие функции

```haskell

id x = x

const x y = x

```

## Функции высших порядков (комбинаторы, функционалы)

### Аппликация как функция

```haskell

apply f x = f x

-- обозначим символом ($)
($) f x = f x
f $ x = f x

-- применим эта-редукцию
($) f x = f x
($) f   = f

-- но это же определение id!
($) f = f
id  x = x
($) == id

```

### Композиция

```haskell

-- определение
f . g = \x -> f (g x)

-- перенесём x в левую часть
(f . g) x = f (g x)

-- заменим простую аппликацию на ($)

f . g $ x =
f $ g $ x

```

## Функции нескольких переменных

Оказывается, функции нескольких переменных не нужны,
когда есть сахар для передачи аргументов по очереди.

Но иногда нужны функции от кортежей.

```haskell

f₁(x, y) = x + y

f₂ x  y  = x + y

f₁ /= f₂
f₁  ≈ f₂

    ╭──curry──╮
    │         ▼
f₁(x, y)    f₂ x y
    ▲         │
    ╰─uncurry─╯

curry   f = \ x  y  -> f (x, y)
uncurry f = \(x, y) -> f  x  y

-- пример
fst (x, _) = x
snd (_, y) = y

curry fst = \x y -> fst (x, y)
          = \x y -> x
          = const

uncurry const = \(x, y) -> const x y
              = \(x, y) -> x
              = fst

curry snd = \x y -> snd (x, y)
          = \x y -> y
          = \x -> \y -> y
          = \x -> id
          = const id

uncurry id  = \(x, y) -> id x y
            = \(x, y) -> x y

```
